<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>abracad.avro documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Abracad 0.4.10 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="abracad.avro.html"><span>abracad.avro</span></a></li><li><a href="abracad.avro.edn.html"><span>abracad.avro.edn</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="abracad.avro.html#var-*avro-readers*"><span>*avro-readers*</span></a></li><li><a href="abracad.avro.html#var--seekable-input"><span>-seekable-input</span></a></li><li><a href="abracad.avro.html#var-AvroSerializable"><span>AvroSerializable</span></a></li><li><a href="abracad.avro.html#var-PSeekableInput"><span>PSeekableInput</span></a></li><li><a href="abracad.avro.html#var-binary-decoder"><span>binary-decoder</span></a></li><li><a href="abracad.avro.html#var-binary-encoded"><span>binary-encoded</span></a></li><li><a href="abracad.avro.html#var-binary-encoder"><span>binary-encoder</span></a></li><li><a href="abracad.avro.html#var-compare"><span>compare</span></a></li><li><a href="abracad.avro.html#var-data-file-reader"><span>data-file-reader</span></a></li><li><a href="abracad.avro.html#var-data-file-writer"><span>data-file-writer</span></a></li><li><a href="abracad.avro.html#var-datum-reader"><span>datum-reader</span></a></li><li><a href="abracad.avro.html#var-datum-writer"><span>datum-writer</span></a></li><li><a href="abracad.avro.html#var-decode"><span>decode</span></a></li><li><a href="abracad.avro.html#var-decode-seq"><span>decode-seq</span></a></li><li><a href="abracad.avro.html#var-direct-binary-decoder"><span>direct-binary-decoder</span></a></li><li><a href="abracad.avro.html#var-direct-binary-encoder"><span>direct-binary-encoder</span></a></li><li><a href="abracad.avro.html#var-encode"><span>encode</span></a></li><li><a href="abracad.avro.html#var-field-get"><span>field-get</span></a></li><li><a href="abracad.avro.html#var-field-list"><span>field-list</span></a></li><li><a href="abracad.avro.html#var-grouping-schema"><span>grouping-schema</span></a></li><li><a href="abracad.avro.html#var-json-decoder"><span>json-decoder</span></a></li><li><a href="abracad.avro.html#var-json-encoded"><span>json-encoded</span></a></li><li><a href="abracad.avro.html#var-json-encoder"><span>json-encoder</span></a></li><li><a href="abracad.avro.html#var-mslurp"><span>mslurp</span></a></li><li><a href="abracad.avro.html#var-mspit"><span>mspit</span></a></li><li><a href="abracad.avro.html#var-parse-schema"><span>parse-schema</span></a></li><li><a href="abracad.avro.html#var-schema-name"><span>schema-name</span></a></li><li><a href="abracad.avro.html#var-schema%3F"><span>schema?</span></a></li><li><a href="abracad.avro.html#var-seekable-input"><span>seekable-input</span></a></li><li><a href="abracad.avro.html#var-slurp"><span>slurp</span></a></li><li><a href="abracad.avro.html#var-spit"><span>spit</span></a></li><li><a href="abracad.avro.html#var-tuple-schema"><span>tuple-schema</span></a></li><li><a href="abracad.avro.html#var-unparse-schema"><span>unparse-schema</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>abracad.avro documentation</h2><pre class="doc">Functions for de/serializing data with Avro.
</pre><div class="public" id="var-*avro-readers*"><h3>*avro-readers*</h3><div class="usage"></div><pre class="doc">Like `clojure.core/*data-readers*`, but for reading Avro records.
Initializes with merged contents of `avro_readers.clj` resources.
Whenever an Avro record is deserialized, the Clojure datum reader will
check this map for a key matching the Avro record name represented as
a namespace-qualified symbol.  When found, the datum reader will
invoke the associated value as a function on the deserialized record's
fields as positional arguments.  The datum reader will use the return
value as the deserialization result.</pre></div><div class="public" id="var--seekable-input"><h3>-seekable-input</h3><div class="usage"><code>(-seekable-input x opts)</code></div><pre class="doc">Attempt to coerce `x` to an Avro `SeekableInput`.
</pre></div><div class="public" id="var-AvroSerializable"><h3>AvroSerializable</h3><div class="usage"></div><pre class="doc">Protocol for customizing Avro serialization.
</pre></div><div class="public" id="var-PSeekableInput"><h3>PSeekableInput</h3><div class="usage"></div><pre class="doc">Protocol for coercing to an Avro `SeekableInput`.
</pre></div><div class="public" id="var-binary-decoder"><h3>binary-decoder</h3><div class="usage"><code>(binary-decoder source)</code></div><pre class="doc">Return a binary-encoding decoder for `source`.  The `source` may be
an input stream, a byte array, or a vector of `[bytes off len]`.</pre></div><div class="public" id="var-binary-encoded"><h3>binary-encoded</h3><div class="usage"><code>(binary-encoded schema &amp; records)</code></div><pre class="doc">Return bytes produced by binary-encoding `records` with `schema`
via `encode`.</pre></div><div class="public" id="var-binary-encoder"><h3>binary-encoder</h3><div class="usage"><code>(binary-encoder sink)</code></div><pre class="doc">Return a binary-encoding encoder for `sink`.
</pre></div><div class="public" id="var-compare"><h3>compare</h3><div class="usage"><code>(compare schema x y)</code></div><pre class="doc">Compare `x` and `y` according to `schema`.
</pre></div><div class="public" id="var-data-file-reader"><h3>data-file-reader</h3><div class="usage"><code>(data-file-reader source)</code><code>(data-file-reader expected source)</code></div><pre class="doc">Return an Avro DataFileReader which produces Clojure data structures.
</pre></div><div class="public" id="var-data-file-writer"><h3>data-file-writer</h3><div class="usage"><code>(data-file-writer)</code><code>(data-file-writer sink)</code><code>(data-file-writer schema sink)</code><code>(data-file-writer codec schema sink)</code></div><pre class="doc">Return an Avro DataFileWriter which consumes Clojure data structures.
</pre></div><div class="public" id="var-datum-reader"><h3>datum-reader</h3><div class="usage"><code>(datum-reader)</code><code>(datum-reader schema)</code><code>(datum-reader expected actual)</code></div><pre class="doc">Return an Avro DatumReader which produces Clojure data structures.
</pre></div><div class="public" id="var-datum-writer"><h3>datum-writer</h3><div class="usage"><code>(datum-writer)</code><code>(datum-writer schema)</code></div><pre class="doc">Return an Avro DatumWriter which consumes Clojure data structures.
</pre></div><div class="public" id="var-decode"><h3>decode</h3><div class="usage"><code>(decode schema source)</code></div><pre class="doc">Decode and return one object from `source` using `schema`.  The
`source` may be an existing Decoder object or anything on which
a (binary-encoding) Decoder may be opened.</pre></div><div class="public" id="var-decode-seq"><h3>decode-seq</h3><div class="usage"><code>(decode-seq schema source)</code></div><pre class="doc">As per `decode`, but decode and return a sequence of all objects
decoded serially from `source`.</pre></div><div class="public" id="var-direct-binary-decoder"><h3>direct-binary-decoder</h3><div class="usage"><code>(direct-binary-decoder source)</code></div><pre class="doc">Return a non-buffered binary-encoding decoder for `source`.
</pre></div><div class="public" id="var-direct-binary-encoder"><h3>direct-binary-encoder</h3><div class="usage"><code>(direct-binary-encoder sink)</code></div><pre class="doc">Return an unbuffered binary-encoding encoder for `sink`.
</pre></div><div class="public" id="var-encode"><h3>encode</h3><div class="usage"><code>(encode schema sink &amp; records)</code></div><pre class="doc">Serially encode each record in `records` to `sink` using `schema`.
The `sink` may be an existing Encoder object, or anything on which
a (binary-encoding) Encoder may be opened.</pre></div><div class="public" id="var-field-get"><h3>field-get</h3><div class="usage"><code>(field-get this field)</code></div><pre class="doc">Value of keyword `field` for Avro serialization of object.
</pre></div><div class="public" id="var-field-list"><h3>field-list</h3><div class="usage"><code>(field-list this)</code></div><pre class="doc">List of keyword fields this object provides.
</pre></div><div class="public" id="var-grouping-schema"><h3>grouping-schema</h3><div class="usage"><code>(grouping-schema n schema)</code></div><pre class="doc">Produce a grouping schema version of record schema `schema` which ignores all
but the first `n` fields when sorting.</pre></div><div class="public" id="var-json-decoder"><h3>json-decoder</h3><div class="usage"><code>(json-decoder schema source)</code></div><pre class="doc">Return a JSON-encoding decoder for `source` using `schema`.
</pre></div><div class="public" id="var-json-encoded"><h3>json-encoded</h3><div class="usage"><code>(json-encoded schema &amp; records)</code></div><pre class="doc">Return string produced by JSON-encoding `records` with `schema`
via `encode`.</pre></div><div class="public" id="var-json-encoder"><h3>json-encoder</h3><div class="usage"><code>(json-encoder schema sink)</code></div><pre class="doc">Return a JSON-encoding encoder for `sink` using `schema`.
</pre></div><div class="public" id="var-mslurp"><h3>mslurp</h3><div class="usage"><code>(mslurp f &amp; opts)</code></div><pre class="doc">Like Avro `slurp`, but produces a sequence of records.
</pre></div><div class="public" id="var-mspit"><h3>mspit</h3><div class="usage"><code>(mspit schema f content &amp; opts)</code></div><pre class="doc">Like Avro `spit`, but emits `content` as a sequence of records.
</pre></div><div class="public" id="var-parse-schema"><h3>parse-schema</h3><div class="usage"><code>(parse-schema source)</code><code>(parse-schema source &amp; sources)</code></div><pre class="doc">Parse Avro schemas in `source` and `sources`.  Each schema source may be a
JSON string, an input stream containing a JSON schema, a Clojure data structure
which may be converted to a JSON schema, or an already-parsed Avro schema
object.  The schema for each subsequent source may refer to the types defined in
the previous schemas.  The parsed schema from the final source is returned.</pre></div><div class="public" id="var-schema-name"><h3>schema-name</h3><div class="usage"><code>(schema-name this)</code></div><pre class="doc">Full package-/namespace-qualified name for Avro purposes.
</pre></div><div class="public" id="var-schema%3F"><h3>schema?</h3><div class="usage"><code>(schema? schema)</code></div><pre class="doc">True iff `schema` is an Avro `Schema` instance.
</pre></div><div class="public" id="var-seekable-input"><h3>seekable-input</h3><div class="usage"><code>(seekable-input x)</code><code>(seekable-input opts x)</code></div><pre class="doc">Attempt to coerce `x` to an Avro `SeekableInput`.
</pre></div><div class="public" id="var-slurp"><h3>slurp</h3><div class="usage"><code>(slurp f &amp; opts)</code></div><pre class="doc">Like core `slurp`, but reads Avro content from `f`.
</pre></div><div class="public" id="var-spit"><h3>spit</h3><div class="usage"><code>(spit schema f content &amp; opts)</code></div><pre class="doc">Like core `spit`, but emits `content` to `f` as Avro with `schema`.
</pre></div><div class="public" id="var-tuple-schema"><h3>tuple-schema</h3><div class="usage"><code>(tuple-schema types)</code><code>(tuple-schema name types)</code></div><pre class="doc">Return Clojure-data Avro schema for record consisting of fields of the
provided `types`, and optionally named `name`.</pre></div><div class="public" id="var-unparse-schema"><h3>unparse-schema</h3><div class="usage"><code>(unparse-schema schema)</code></div><pre class="doc">Return Avro-normalized Clojure data version of `schema`.  If `schema` is not
already a parsed schema, will first normalize and parse it.</pre></div></div></body></html>